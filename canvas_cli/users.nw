This chapter provides the subcommand [[users]], which lists the users of a 
given course.

\section{The subcommand and its options}

We add the subparser for [[users]].
<<add arguments>>=
users_parser = subp.add_parser("users", help="Lists users of a course")
users_parser.set_defaults(func=users_command)
<<set up options for selecting courses>>
<<set up options for selecting type of users>>
@ Now, that [[users_command]] function must take two arguments: [[canvas]] and 
[[args]].
<<functions>>=
def users_command(canvas, args):
  <<process options for selecting courses>>
  <<process options for selecting type of users>>
  <<get users and print them>>
@ We will cover the set up and processing of the options in the following 
subsections.

\subsubsection{Selecting the course}

We provide two ways to identify a course: by Canvas' ID number, which is 
unique, or by matching the course name and course code against a regular 
expression.
We need a course, so we require one of these options, but not both.
<<set up options for selecting courses>>=
course_args = users_parser.add_mutually_exclusive_group(required=True)
course_args.add_argument("-i", "--course-identifier", type=int,
  help="Select course by Canvas unique identifier")
course_args.add_argument("-c", "--course-regex",
  help="Filter courses by regular expression")
@

When we check for either of these arguments, we set up the [[course]] object 
that will be used in [[<<get the list of users>>]].
<<process options for selecting courses>>=
if args.course_identifier:
  course_list = [canvas.get_course(args.course_identifier)]
elif args.course_regex:
  course_list = filter_courses(canvas, args.course_regex)
@ We use the [[filter_courses]] from the \cref{filter-courses}.

\subsubsection{Selecting the type of users}

We also want to be able to filter out the type of users.
For now, we focus on students and teachers.
<<set up options for selecting type of users>>=
users_parser.add_argument("-s", "--students", action="store_true",
  help="Include students.")
users_parser.add_argument("-t", "--teachers", action="store_true",
  help="Include teachers.")
users_parser.add_argument("-a", "--assistants", action="store_true",
  help="Include teaching assistants.")
@

We want students by default, if the user doesn't specify anything.
Otherwise, we add them together.
<<process options for selecting type of users>>=
roles = []
if args.students:
  roles.append("student")
if args.teachers:
  roles.append("teacher")
if args.assistants:
  roles.append("ta")
@


\subsection{Get and print the list of users}

We then simply call the list-users function with the [[canvas]] object as the 
parameter.
We will use the [[course_list]] and [[roles]] lists created above to get the 
list of users.
Then we will print the most useful attributes (identifiers) of a user.
<<get users and print them>>=
users = list_users(course_list, roles)
for user in users:
  print(f"{user.id}\t{user.sis_user_id}\t{user.email}\t{user.name}")
@


\section{Listing our users}

This module simply lists the users of a course on Canvas in a format that is 
aligned with the UNIX-philosophy, i.e.~can easily be used in scripts.

This part provides two things.
First, it provides a set of functions that will return a list of our Canvas 
users based on some parameters.
Second, it provides a command-line interface to (some of) those functions 
(Sect.~\ref{command-line-interface}).


\section{Producing a list of users}%
\label{list-users-function}

We provide the following functions:
\begin{itemize}
  \item [[list_students]], which returns a list of enrolled students;
  \item [[list_teachers]], which returns a list of teachers;
  \item [[list_users]], which is a general function that also takes a list of 
  roles.
\end{itemize}

First, we provide the most general function, [[list_users]], which takes a list 
of courses and a list of Canvas roles as argument.
<<functions>>=
def list_users(courses, roles):
  for course in courses:
    users = course.get_users(enrollment_type=roles)
    for user in users:
      yield user
@

Now, we can define the function~[[list_students]] in terms of 
[[list_users]].
<<functions>>=
def list_students(courses):
  return list_users(courses, ["student"])

def list_teachers(courses):
  return list_users(courses, ["teacher"])
@

